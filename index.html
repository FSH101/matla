<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matreshka API (Browser Demo)</title>
  <style>
    :root { color-scheme: dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; background:#0b0f14; color:#e6edf3; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 14px; max-width: 1100px; margin: 0 auto; }
    .card { background:#111826; border:1px solid #223044; border-radius: 12px; padding: 12px; }
    h1 { font-size: 18px; margin: 0 0 8px; }
    h2 { font-size: 14px; margin: 0 0 10px; color:#c6d6ff; }
    label { display:block; font-size: 12px; opacity:.9; margin: 8px 0 4px; }
    input, select, textarea, button { width: 100%; box-sizing: border-box; padding: 10px; border-radius: 10px; border: 1px solid #2b3a52; background:#0b1220; color:#e6edf3; }
    textarea { min-height: 90px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .row { display:flex; gap: 10px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 180px; }
    button { cursor:pointer; background:#16233a; }
    button:hover { background:#1b2b47; }
    .small { font-size: 12px; opacity: .85; line-height: 1.35; }
    pre { white-space: pre-wrap; word-break: break-word; background:#0a1220; border:1px solid #223044; border-radius: 12px; padding: 10px; margin: 8px 0 0; }
    .ok { color:#9cffc6; }
    .bad { color:#ffb4b4; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #2b3a52; font-size:12px; opacity:.95; }
    .muted { opacity:.75; }
  </style>
</head>
<body>
  <div class="grid">
    <div class="card">
      <h1>Matreshka API (Browser Demo) <span class="pill muted">v18-20251229001345</span></h1>
      <div class="small">
        Демо дергает публичные URL через Cloudflare Worker‑прокси (иначе CORS блокирует). Если кнопки вдруг «не нажимаются» — это почти всегда
        означает, что JavaScript упал (ошибка покажется в Output).
      </div>
    </div>

    <div class="card">
      <h2>Сессия</h2>

      <label>proxyBase (Cloudflare Worker)</label>
      <input id="proxyBase" type="text" placeholder="https://xxxx.workers.dev/?url=" />

      <div class="row">
        <div>
          <label>deviceHash</label>
          <input id="deviceHash" type="text" />
        </div>
        <div>
          <label>client</label>
          <select id="client">
            <option value="prod" selected>prod</option>
            <option value="google">google</option>
            <option value="appgallery">appgallery</option>
            <option value="rustore">rustore</option>
          </select>
        </div>
      </div>

      <div class="row">
        <div>
          <label>accountId</label>
          <input id="accountId" type="number" />
        </div>
        <div>
          <label>sessionHash</label>
          <input id="sessionHash" type="text" />
        </div>
      </div>

      <div class="row">
        <button id="btnSave">Save (localStorage)</button>
        <button id="btnLoad">Load</button>
        <button id="btnNewDevice">New deviceHash</button>
      </div>

      <div class="small">После обновления GitHub Pages делай <b>Ctrl+F5</b> или открывай в инкогнито — иначе кеш.</div>
    </div>

    <div class="card">
      <h2>Публичные конфиги</h2>
      <div class="row">
        <button id="btnUpdate">GET update.php</button>
        <button id="btnMain">GET api/main.json</button>
        <button id="btnServersJson">GET servers.json</button>
      </div>

      <label>files_list URL</label>
      <div class="row">
        <input id="filesListUrl" type="text" placeholder="https://moblauncher.matrp.ru/files_list/build1411.json" />
        <button id="btnFilesList">GET files_list</button>
      </div>
    </div>

    <div class="card">
      <h2>Email auth</h2>
      <div class="small">
        Браузер шлёт <b>POST</b> на Worker (чтобы пароль не светился в URL страницы). Worker по умолчанию превращает POST‑поля в <b>GET</b> к апстриму,
        потому что их Auth.php чаще всего ждёт GET.
      </div>

      <div class="row">
        <div>
          <label>email</label>
          <input id="email" type="text" placeholder="name@example.com" />
        </div>
        <div>
          <label>password</label>
          <input id="pass" type="password" />
        </div>
      </div>

      <div class="row">
        <button id="btnLogin">Login (email/auth)</button>
        <button id="btnRegStart">Register (email/register)</button>
      </div>

      <div class="row">
        <div>
          <label>verification code</label>
          <input id="code" type="text" />
        </div>
        <button id="btnRegFinish">Register code (email/register_code)</button>
      </div>

      <label style="display:flex; gap:8px; align-items:center; margin:10px 0 0;">
        <input id="authIncludeSession" type="checkbox" checked />
        <span class="small">Добавлять accountId/sessionHash в Auth (обычно не нужно)</span>
      </label>
    </div>

    <div class="card">
      <h2>Авторизованные запросы</h2>
      <div class="row">
        <button id="btnServersApi">GET /api/Requests/Servers.php</button>
        <button id="btnAccount">GET /api/Requests/AccountDetails.php</button>
        <button id="btnCabinet">GET /api/Requests/Cabinet.php</button>
      </div>

      <div class="row">
        <div>
          <label>Server host</label>
          <input id="srvHost" type="text" placeholder="91.220.80.xx" />
        </div>
        <div>
          <label>Server port</label>
          <input id="srvPort" type="number" placeholder="7777" />
        </div>
      </div>

      <div class="row">
        <button id="btnSelectServer">SelectServer.php</button>
        <button id="btnPlay">Play.php</button>
      </div>
    </div>

    <div class="card">
      <h2>Custom request</h2>
      <div class="row">
        <div>
          <label>URL</label>
          <input id="customUrl" type="text" placeholder="https://moblauncher.matrp.ru/servers.json" />
        </div>
        <div>
          <label>Method</label>
          <select id="customMethod">
            <option value="GET" selected>GET</option>
            <option value="POST">POST</option>
          </select>
        </div>
      </div>

      <label>POST form (key=value&...)</label>
      <textarea id="customBody" placeholder="type=email&subtype=auth&action=continue&email=...&pass=..."></textarea>

      <label style="display:flex; gap:8px; align-items:center; margin:10px 0 0;">
        <input id="customUpstreamPost" type="checkbox" />
        <span class="small">Для POST: реально отправлять POST апстриму (upstream=post). Иначе Worker превратит в GET.</span>
      </label>

      <div class="row">
        <button id="btnCustom">Send</button>
        <button id="btnDebugUpstream">Worker debug=1</button>
      </div>
    </div>

    <div class="card">
      <h2>Output</h2>
      <pre id="out">(ready)</pre>
    </div>
  </div>

<script>
(function () {
  "use strict";
  function qs(id) { return document.getElementById(id); }

  function setOut(o, ok) {
    var el = qs("out");
    try { el.textContent = (typeof o === "string") ? o : JSON.stringify(o, null, 2); }
    catch (e) { el.textContent = String(o); }
    el.className = ok ? "ok" : "bad";
  }

  window.addEventListener("error", function (ev) {
    setOut({ ok:false, error:"JS error", message: ev.message, filename: ev.filename, lineno: ev.lineno, colno: ev.colno }, false);
  });

  function sanitizeEmail(s) {
    return String(s || "")
      .replace(/[\u200B-\u200D\uFEFF]/g, "")
      .replace(/\s+/g, "")
      .trim()
      .toLowerCase();
  }

  function randDeviceHash() {
    var chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    var s = "";
    for (var i = 0; i < 16; i++) s += chars.charAt(Math.floor(Math.random() * chars.length));
    return s;
  }

  function parseForm(text) {
    var obj = {};
    if (!text) return obj;
    var t = String(text).trim();
    if (!t) return obj;
    var parts = (t.indexOf("&") !== -1) ? t.split("&") : t.split(/\n+/);
    for (var i = 0; i < parts.length; i++) {
      var p = String(parts[i] || "").trim();
      if (!p) continue;
      var eq = p.indexOf("=");
      if (eq === -1) continue;
      var k = decodeURIComponent(p.slice(0, eq).trim());
      var v = decodeURIComponent(p.slice(eq + 1).trim());
      obj[k] = v;
    }
    return obj;
  }

  function buildFormBody(obj) {
    var parts = [];
    for (var k in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
      var v = obj[k];
      if (v === undefined || v === null) v = "";
      parts.push(encodeURIComponent(k) + "=" + encodeURIComponent(String(v)));
    }
    return parts.join("&");
  }

  function normalizeProxyBase(base) {
    var b = String(base || "").trim();
    if (!b) return "";
    if (b.indexOf("url=") === -1) {
      if (b.indexOf("?") === -1) b += "?url=";
      else b += "&url=";
      return b;
    }
    return b;
  }

  async function decodeTextSmart(resp) {
    var buf = await resp.arrayBuffer();
    var t1 = "", t2 = "";
    try { t1 = new TextDecoder("utf-8").decode(buf); } catch (e) {}
    try { t2 = new TextDecoder("windows-1251").decode(buf); } catch (e) {}
    var bad = (t1.indexOf("�") !== -1) || (t1.indexOf("����") !== -1);
    if (bad && t2 && t2.indexOf("�") === -1) return t2;
    return t1 || t2 || "";
  }

  var state = {
    api: "https://moblauncher.matrp.ru",
    proxyBase: "",
    deviceHash: "",
    client: "prod",
    accountId: -1,
    sessionHash: ""
  };

  function loadState() {
    try {
      var s = localStorage.getItem("mat_demo_state_v16");
      if (s) {
        var o = JSON.parse(s);
        if (o && typeof o === "object") for (var k in o) state[k] = o[k];
      }
    } catch (e) {}
  }

  function saveState() {
    try { localStorage.setItem("mat_demo_state_v16", JSON.stringify(state)); } catch (e) {}
  }

  function renderState() {
    qs("proxyBase").value = state.proxyBase || "";
    qs("deviceHash").value = state.deviceHash || "";
    qs("client").value = state.client || "prod";
    qs("accountId").value = String(state.accountId);
    qs("sessionHash").value = state.sessionHash || "";
  }

  function pullStateFromUI() {
    state.proxyBase = normalizeProxyBase(qs("proxyBase").value);
    state.deviceHash = String(qs("deviceHash").value || "").trim();
    if (!state.deviceHash) state.deviceHash = randDeviceHash();
    qs("deviceHash").value = state.deviceHash;

    state.client = String(qs("client").value || "prod").trim() || "prod";
    state.accountId = parseInt(qs("accountId").value, 10);
    if (isNaN(state.accountId)) state.accountId = -1;
    state.sessionHash = String(qs("sessionHash").value || "").trim();
  }

  function withBaseParams(obj, includeSession) {
    var o = {};
    for (var k in obj) o[k] = obj[k];
    o.deviceHash = state.deviceHash;
    o.client = state.client;
    if (includeSession) {
      o.accountId = state.accountId;
      o.sessionHash = state.sessionHash || "";
    }
    return o;
  }

  async function fetchViaProxy(method, url, formObj, workerExtraParams) {
    pullStateFromUI();
    if (!state.proxyBase) return { ok:false, status:0, error:"proxyBase пустой" };

    var extra = String(workerExtraParams || "");
    var workerUrl = state.proxyBase + encodeURIComponent(url) + extra;

    var opts = { method: method };
    if (method === "POST") {
      opts.headers = { "content-type": "application/x-www-form-urlencoded; charset=utf-8" };
      opts.body = buildFormBody(formObj || {});
    }

    var resp;
    try { resp = await fetch(workerUrl, opts); }
    catch (e) { return { ok:false, status:0, error:String(e) }; }

    var contentType = resp.headers.get("content-type") || "";
    var rawText = await decodeTextSmart(resp);

    try {
      var parsed = JSON.parse(rawText);
      if (parsed === null) return { ok: resp.ok, status: resp.status, contentType: contentType, parsed: null, raw: rawText };
      return parsed;
    } catch (e) {
      return { ok: resp.ok, status: resp.status, contentType: contentType, raw: rawText };
    }
  }

  async function getUpdate() {
    var url = state.api + "/update.php?accountId=-1&deviceHash=" + encodeURIComponent(state.deviceHash) + "&client=" + encodeURIComponent(state.client);
    var res = await fetchViaProxy("GET", url);
    if (res && res.files_list) qs("filesListUrl").value = res.files_list;
    setOut(res, true);
  }

  async function getMain() { setOut(await fetchViaProxy("GET", state.api + "/api/main.json"), true); }
  async function getServersJson() { setOut(await fetchViaProxy("GET", state.api + "/servers.json"), true); }

  async function getFilesList() {
    var url = String(qs("filesListUrl").value || "").trim();
    if (!url) return setOut({ ok:false, error:"files_list URL пустой" }, false);
    setOut(await fetchViaProxy("GET", url), true);
  }

  async function authEmail(subtype, extra) {
    var includeSession = qs("authIncludeSession").checked ? true : false; // если включено — добавляем accountId/sessionHash (даже -1/пусто)
    var url = state.api + "/api/Requests/Auth.php";

    var data = withBaseParams({ type:"email", subtype: subtype, action:"continue" }, includeSession);
    if (includeSession) {
      // Важно: лаунчер обычно шлёт эти поля всегда; даже если sessionHash пустой.
      if (data.accountId === undefined || data.accountId === null || isNaN(parseInt(String(data.accountId), 10))) data.accountId = -1;
      if (data.sessionHash === undefined || data.sessionHash === null) data.sessionHash = "";
    }
    for (var k in (extra || {})) data[k] = extra[k];

    var res = await fetchViaProxy("POST", url, data);

    try {
      var a0 = res && res.actions && res.actions[0] ? res.actions[0] : null;
      if (a0 && a0.account_id !== undefined && a0.account_id !== null) {
        state.accountId = a0.account_id;
        state.sessionHash = a0.session_hash || "";
        saveState(); renderState();
      }
    } catch (e) {}

    setOut(res, true);
  }

  async function authedGet(path) {
    pullStateFromUI();
    if (!state.sessionHash) return setOut({ ok:false, error:"sessionHash пустой — нужна авторизация" }, false);
    var base = state.api + path;
    var url = base + "?" + buildFormBody(withBaseParams({}, true));
    setOut(await fetchViaProxy("GET", url), true);
  }

  async function selectServer() {
    pullStateFromUI();
    if (!state.sessionHash) return setOut({ ok:false, error:"Необходимо авторизоваться (sessionHash пустой)" }, false);
    var host = String(qs("srvHost").value || "").trim();
    var port = String(qs("srvPort").value || "").trim();
    if (!host || !port) return setOut({ ok:false, error:"host/port пустые" }, false);

    var url = state.api + "/api/Requests/SelectServer.php";
    var q = buildFormBody(withBaseParams({ host: host, port: port }, true));
    setOut(await fetchViaProxy("GET", url + "?" + q), true);
  }

  async function play() {
    pullStateFromUI();
    var host = String(qs("srvHost").value || "").trim();
    var port = String(qs("srvPort").value || "").trim();
    var url = state.api + "/api/Requests/Play.php";
    var q = buildFormBody(withBaseParams({ host: host, port: port }, true));
    setOut(await fetchViaProxy("GET", url + "?" + q), true);
  }

  async function customSend() {
    pullStateFromUI();
    var url = String(qs("customUrl").value || "").trim();
    if (!url) return setOut({ ok:false, error:"URL пустой" }, false);

    var method = String(qs("customMethod").value || "GET");
    var bodyObj = parseForm(qs("customBody").value || "");
    var upstreamPost = qs("customUpstreamPost").checked;
    var extra = upstreamPost ? "&upstream=post" : "";

    if (method === "POST") setOut(await fetchViaProxy("POST", url, bodyObj, extra), true);
    else setOut(await fetchViaProxy("GET", url), true);
  }

  async function workerDebug() {
    pullStateFromUI();
    var url = String(qs("customUrl").value || "").trim();
    if (!url) return setOut({ ok:false, error:"URL пустой" }, false);

    var method = String(qs("customMethod").value || "GET");
    var bodyObj = parseForm(qs("customBody").value || "");
    var upstreamPost = qs("customUpstreamPost").checked;
    var extra = "&debug=1" + (upstreamPost ? "&upstream=post" : "");

    if (method === "POST") setOut(await fetchViaProxy("POST", url, bodyObj, extra), true);
    else setOut(await fetchViaProxy("GET", url, null, extra), true);
  }

  function bind() {
    qs("btnSave").addEventListener("click", function () { pullStateFromUI(); saveState(); setOut({ ok:true, saved: state }, true); });
    qs("btnLoad").addEventListener("click", function () { loadState(); renderState(); setOut({ ok:true, loaded: state }, true); });
    qs("btnNewDevice").addEventListener("click", function () { state.deviceHash = randDeviceHash(); saveState(); renderState(); setOut({ ok:true, deviceHash: state.deviceHash }, true); });

    qs("btnUpdate").addEventListener("click", getUpdate);
    qs("btnMain").addEventListener("click", getMain);
    qs("btnServersJson").addEventListener("click", getServersJson);
    qs("btnFilesList").addEventListener("click", getFilesList);

    qs("btnLogin").addEventListener("click", function () {
      var email = sanitizeEmail(qs("email").value);
      var pass = String(qs("pass").value || "");
      authEmail("auth", { email: email, pass: pass });
    });

    qs("btnRegStart").addEventListener("click", function () {
      var email = sanitizeEmail(qs("email").value);
      var pass = String(qs("pass").value || "");
      authEmail("register", { email: email, pass: pass, repeat_pass: pass });
    });

    qs("btnRegFinish").addEventListener("click", function () {
      var email = sanitizeEmail(qs("email").value);
      var pass = String(qs("pass").value || "");
      var code = String(qs("code").value || "").trim();
      authEmail("register_code", { email: email, pass: pass, repeat_pass: pass, code: code });
    });

    qs("btnServersApi").addEventListener("click", function(){ authedGet("/api/Requests/Servers.php"); });
    qs("btnAccount").addEventListener("click", function(){ authedGet("/api/Requests/AccountDetails.php"); });
    qs("btnCabinet").addEventListener("click", function(){ authedGet("/api/Requests/Cabinet.php"); });

    qs("btnSelectServer").addEventListener("click", selectServer);
    qs("btnPlay").addEventListener("click", play);

    qs("btnCustom").addEventListener("click", customSend);
    qs("btnDebugUpstream").addEventListener("click", workerDebug);

    setOut("(ready)", true);
  }

  loadState();
  if (!state.deviceHash) state.deviceHash = randDeviceHash();
  renderState();
  bind();
})();
</script>
</body>
</html>

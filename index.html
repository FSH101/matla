<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Matreshka API — браузерный демо-клиент</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:24px;max-width:980px}
    h1{margin:0 0 8px}
    .muted{color:#666}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:16px}
    .card{border:1px solid #ddd;border-radius:12px;padding:16px}
    label{display:block;margin:10px 0 6px}
    input,select,button,textarea{font:inherit}
    input,select{width:100%;padding:10px;border:1px solid #ccc;border-radius:10px}
    button{padding:10px 12px;border:1px solid #ccc;border-radius:10px;background:#fff;cursor:pointer;margin:6px 6px 0 0}
    button.primary{border-color:#333}
    button:disabled{opacity:.6;cursor:not-allowed}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b1020;color:#e6e6e6;padding:12px;border-radius:12px;min-height:160px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .pill{display:inline-block;padding:4px 10px;border:1px solid #ddd;border-radius:999px;font-size:12px;margin-right:8px}
    .danger{color:#b00020}
    .ok{color:#0a7}
    small code{background:#f5f5f5;padding:2px 6px;border-radius:6px}
  </style>
</head>
<body>
  <h1>Matreshka API — демо из браузера</h1>
  <div class="muted">
    Это минимальный сайт, который запускает твой JS-клиент прямо в браузере.
    <span class="pill" id="status">не авторизован</span>
    <span class="pill" id="devicePill"></span>
  </div>

  <p class="danger">
    Важно: пароль уходит в URL (GET-запрос) — так устроен их API. Не используй реальный пароль на чужих сайтах и не делай это на «чужом» компьютере.
  </p>

  <div class="grid">
    <div class="card">
      <h3>1) Авторизация / Регистрация</h3>

      <label>Email</label>
      <input id="email" type="email" placeholder="mail@example.com" autocomplete="username" />

      <label>Пароль</label>
      <input id="password" type="password" placeholder="••••••••" autocomplete="current-password" />

      <label>Прокси (Cloudflare Worker URL, опционально)</label>
      <input id="proxy" type="url" placeholder="https://<name>.workers.dev/?url=" />

      <label>Код подтверждения (для регистрации)</label>
      <input id="code" type="text" placeholder="1234" inputmode="numeric" />

      <div class="row">
        <button class="primary" id="btnLogin">Login</button>
        <button id="btnReqCode">Запросить код</button>
        <button id="btnRegister">Register</button>
        <button id="btnLogout">Сбросить сессию</button>
      </div>

      <p class="muted">
        Подсказка по регистрации: сначала жми <b>«Запросить код»</b>, дождись письма, введи код и только потом <b>Register</b>.
      </p>

      <p class="muted">
        В браузере нельзя вручную поставить заголовок <code>User-Agent</code> — он игнорируется (ограничение безопасности браузеров).
        Если сервер реально требует мобильный UA, понадобится прокси (см. README).
      </p>
    </div>

    <div class="card">
      <h3>2) Запросы</h3>

      <label>Метод</label>
      <select id="method">
        <option value="getStories">getStories</option>
        <option value="getServers">getServers</option>
        <option value="getSocialBonusInfo">getSocialBonusInfo</option>
        <option value="getAccountDetails">getAccountDetails</option>
        <option value="getCabinet">getCabinet</option>
        <option value="getFaq">getFaq</option>
        <option value="getAudios">getAudios</option>
        <option value="getRadios">getRadios</option>
        <option value="getUpdate">getUpdate</option>
      </select>

      <div class="row">
        <button class="primary" id="btnCall">Выполнить</button>
        <button id="btnCopy">Копировать JSON</button>
        <button id="btnClear">Очистить</button>
      </div>

      <p class="muted">
        Если получишь ошибку <code>CORS</code> — это значит, что API не разрешает запросы из браузера напрямую.
        Тогда включай прокси-режим (README).
      </p>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3>3) Сессия</h3>
      <div class="row">
        <button id="btnShowSession" class="primary">Показать сессию</button>
        <button id="btnClearSession">Очистить сессию</button>
        <button id="btnCopySession">Копировать</button>
        <button id="btnResetDeviceHash" title="Сбросит deviceHash. Старые коды регистрации могут стать недействительными.">Сбросить deviceHash</button>
      </div>
      <p class="muted">
        Их “токен” — это обычно <code>sessionHash</code> (в ответах часто <code>session_hash</code>) + <code>accountId</code> + <code>deviceHash</code>. Для регистрации <code>deviceHash</code> должен оставаться тем же между «Запросить код» и «Register» (в v8 он сохраняется в localStorage).
      </p>
      <pre id="sessionOut">{}</pre>
    </div>

    <div class="card">
      <h3>4) Доп. эндпоинты (main.json)</h3>

      <label>Server IP (для SelectServer/Play, если нужно)</label>
      <input id="srvIp" type="text" placeholder="91.220.80.10" />

      <label>Server Port</label>
      <input id="srvPort" type="number" placeholder="7777" />

      <label>Auth type</label>
      <input id="authType" type="text" value="email" placeholder="email / device / guest (если есть)" />

      <label>Auth subtype</label>
      <input id="authSubtype" type="text" value="auth" placeholder="auth / register / register_code / ..." />

      <label>Email (необязательно для device/guest)</label>
      <input id="authEmail" type="email" placeholder="user@example.com" />

      <label>Пароль (если требуется)</label>
      <input id="authPass" type="password" placeholder="Пароль" />

      <label>Код (для register_code)</label>
      <input id="authCode" type="text" placeholder="123456" />

      <div class="row">
        <button id="btnAuthCustom" class="primary">Auth (custom)</button>
      </div>

      <p class="muted">
        Если в официальном лаунчере есть «Гость», то почти наверняка он получает <code>accountId</code> и <code>sessionHash</code> через <code>Auth.php</code> с другим <code>type</code> (часто <code>device</code>) и/или другим <code>subtype</code>.
        Попробуй варианты: <code>type=device</code> + <code>subtype=auth</code>, или <code>type=guest</code> + <code>subtype=auth</code>.
      </p>

<div class="row">
        <button id="btnVerifyAuth" class="primary">VerifyAuth</button>
        <button id="btnCharacter">Character</button>
        <button id="btnSelectServer">SelectServer</button>
        <button id="btnPlay">Play</button>
        <button id="btnLogout">Logout</button>
      </div>

      <p class="muted">
        Точные параметры <code>SelectServer</code>/<code>Play</code> могут отличаться (сервер может ждать id/slot/host/port).
        Если вернётся ошибка — просто смотри JSON и подстроим параметры.
      </p>

      <pre id="advOut">{}</pre>
    </div>
  </div>

  <h3>Ответ</h3>
  <pre id="out">{}</pre>

  <h3>Последняя версия (update.php)</h3>
  <div class="card">
    <div class="row" style="align-items:center;justify-content:space-between">
      <div class="muted">
        Этот эндпоинт обычно работает даже без логина (accountId=-1) и возвращает ссылки на клиент/лаунчер, files_list и архивы.
      </div>
      <div class="row" style="align-items:center">
        <label style="margin:0;display:flex;align-items:center;gap:8px">
          <input type="checkbox" id="autoUpdate" checked />
          Автозагрузка при открытии
        </label>
        <button class="primary" id="btnLatest">Обновить</button>
      </div>
    </div>
    <pre id="latest">{}</pre>
    <div class="row" style="margin-top:10px;align-items:center">
      <button id="btnFilesList">Загрузить files_list</button>
      <button id="btnFilesListSummary">Показать сводку</button>
      <span class="muted" id="filesListHint"></span>
    </div>
    <pre id="filesListOut">{}</pre>
  </div>

<script>
/**
 * Matreshka — браузерная адаптация твоего класса.
 * Отличия от Node-версии:
 * 1) НЕТ module.exports
 * 2) Нельзя выставить user-agent header
 * 3) Исправлен deviceHash: он должен быть строкой, а не ссылкой на функцию
 */
function loadDeviceHash(){
  try { return localStorage.getItem("matreshka_deviceHash") || ""; } catch { return ""; }
}
function saveDeviceHash(v){
  try { localStorage.setItem("matreshka_deviceHash", v || ""); } catch {}
}

class Matreshka {
  constructor(opts = {}) {
    this.api = opts.api || "https://moblauncher.matrp.ru";
    this.client = opts.client || "prod";
    this.accountId = -1;
    this.sessionHash = "";
    this.deviceHash = loadDeviceHash() || this.generateDeviceHash();
    saveDeviceHash(this.deviceHash); // <-- FIX
    // headers оставим, но user-agent браузер всё равно не даст поставить
    this.headers = opts.headers || {};
    // Если нужен прокси: opts.proxyBase = "https://<твоя_функция>/proxy?url="
    this.proxyBase = opts.proxyBase || null;
  }

  generateDeviceHash() {
    let hash = "";
    const characters = "abcdefghijklmnopqrstuvwxyz0123456789";
    for (let i = 0; i < 16; i++) {
      hash += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return hash;
  }

  _q(params) {
    const usp = new URLSearchParams();
    for (const [k, v] of Object.entries(params)) {
      if (v === undefined || v === null) continue;
      usp.set(k, String(v));
    }
    return usp.toString();
  }

  _withAuthParams(extra = {}) {
    return {
      accountId: this.accountId,
      sessionHash: this.sessionHash,
      deviceHash: this.deviceHash,
      client: this.client,
      ...extra
    };
  }

  async _fetchJson(url) {
    const finalUrl = this.proxyBase ? (this.proxyBase + encodeURIComponent(url)) : url;
    const resp = await fetch(finalUrl, { method: "GET", headers: this.headers });

    // ВАЖНО: некоторые их JSON-ы могут быть НЕ в UTF-8 (часто Windows-1251), из-за чего в браузере появляется '������'.
    // Поэтому читаем как bytes и пробуем декодировать UTF-8 -> fallback windows-1251.
    const ab = await resp.arrayBuffer();

    const tryParse = (text) => {
      try { return { ok: true, value: JSON.parse(text) }; }
      catch { return { ok: false, value: null }; }
    };

    // 1) UTF-8 (по стандарту JSON должен быть UTF-8, но жизнь любит хаос)
    let textUtf8 = new TextDecoder("utf-8").decode(ab);
    let parsed = tryParse(textUtf8);
    if (parsed.ok) return parsed.value;

    // 2) Fallback: Windows-1251 (для кириллицы)
    let text1251 = null;
    try {
      text1251 = new TextDecoder("windows-1251").decode(ab);
      parsed = tryParse(text1251);
      if (parsed.ok) return parsed.value;
    } catch {}

    // 3) Если не JSON — вернём сырое
    return { ok: resp.ok, status: resp.status, contentType: resp.headers.get("content-type"), raw: (text1251 ?? textUtf8) };
  }

  // Публичный хелпер: дернуть любой URL (через прокси, если включен)
  async fetchUrl(url) {
    return this._fetchJson(url);
  }

  async login(email, password) {
    const url = `${this.api}/api/Requests/Auth.php?` + this._q(this._withAuthParams({
      type: "email",
      subtype: "auth",
      action: "continue",
      email,
      pass: password
    }));
    const data = await this._fetchJson(url);
    // Подстраховка: структура ответа может отличаться
    const action0 = data?.actions?.[0];
    if (action0 && ("account_id" in action0)) {
      this.accountId = action0.account_id;
      this.sessionHash = action0.session_hash;
    }
    return data;
  }

  async requestVerificationCode(email, password) {
    const url = `${this.api}/api/Requests/Auth.php?` + this._q(this._withAuthParams({
      type: "email",
      subtype: "register",
      action: "continue",
      email,
      pass: password,
      repeat_pass: password
    }));
    return this._fetchJson(url);
  }

  async register(email, password, verificationCode) {
    const url = `${this.api}/api/Requests/Auth.php?` + this._q(this._withAuthParams({
      type: "email",
      subtype: "register_code",
      action: "continue",
      email,
      pass: password,
      repeat_pass: password,
      code: verificationCode
    }));
    return this._fetchJson(url);
  }

  async authCustom(type, subtype, extra = {}) {
    const base = {
      type,
      subtype,
      action: "continue",
      ...extra,
    };
    // Auth.php использует те же accountId/sessionHash/deviceHash/client что и другие запросы
    const url = `${this.api}/api/Requests/Auth.php?` + this._q(this._withAuthParams(base));
    return this._fetchJson(url);
  }

  async getStories() {
    const url = `${this.api}/api/Requests/Stories.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getServers() {
    const url = `${this.api}/api/Requests/Servers.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getSocialBonusInfo() {
    const url = `${this.api}/api/Requests/SocialBonusInfo.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getAccountDetails() {
    const url = `${this.api}/api/Requests/AccountDetails.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getCabinet() {
    const url = `${this.api}/api/Requests/Cabinet.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async changePassword(password) {
    const url = `${this.api}/api/Requests/Auth.php?` + this._q(this._withAuthParams({
      type: "email",
      subtype: "changepass_old",
      action: "continue",
      pass: password
    }));
    return this._fetchJson(url);
  }
  async getFaq() {
    const url = `${this.api}/api/Requests/FAQ.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getAudios() {
    const url = `${this.api}/audio_list.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getRadios() {
    const url = `${this.api}/radio_list.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }
  async getUpdate() {
    const url = `${this.api}/update.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }

  async verifyAuth() {
    const url = `${this.api}/api/Requests/VerifyAuth.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }

  async logout() {
    const url = `${this.api}/api/Requests/Logout.php?` + this._q(this._withAuthParams());
    return this._fetchJson(url);
  }

  async character(extra = {}) {
    const url = `${this.api}/api/Requests/Character.php?` + this._q(this._withAuthParams(extra));
    return this._fetchJson(url);
  }

  async selectServer(extra = {}) {
    const url = `${this.api}/api/Requests/SelectServer.php?` + this._q(this._withAuthParams(extra));
    return this._fetchJson(url);
  }

  async play(extra = {}) {
    const url = `${this.api}/api/Requests/Play.php?` + this._q(this._withAuthParams(extra));
    return this._fetchJson(url);
  }
}

// --- UI wiring ---
const out = document.getElementById("out");
const statusEl = document.getElementById("status");
const devicePill = document.getElementById("devicePill");
const emailEl = document.getElementById("email");
const passEl  = document.getElementById("password");
const codeEl  = document.getElementById("code");
const methodEl = document.getElementById("method");
const sessionOut = document.getElementById("sessionOut");
const advOut = document.getElementById("advOut");
const btnShowSession = document.getElementById("btnShowSession");
const btnClearSession = document.getElementById("btnClearSession");
const btnCopySession = document.getElementById("btnCopySession");
const btnResetDeviceHash = document.getElementById("btnResetDeviceHash");
const btnVerifyAuth = document.getElementById("btnVerifyAuth");
const btnLogout2 = document.getElementById("btnLogout");
const btnSelectServer = document.getElementById("btnSelectServer");
const btnPlay = document.getElementById("btnPlay");
const btnCharacter = document.getElementById("btnCharacter");
const srvIpEl = document.getElementById("srvIp");
const srvPortEl = document.getElementById("srvPort");
const authTypeEl = document.getElementById("authType");
const authSubtypeEl = document.getElementById("authSubtype");
const authEmailEl = document.getElementById("authEmail");
const authPassEl = document.getElementById("authPass");
const authCodeEl = document.getElementById("authCode");
const btnAuthCustom = document.getElementById("btnAuthCustom");
const latestEl = document.getElementById("latest");
const btnLatest = document.getElementById("btnLatest");
const autoUpdateEl = document.getElementById("autoUpdate");
const btnFilesList = document.getElementById("btnFilesList");
const btnFilesListSummary = document.getElementById("btnFilesListSummary");
const filesListOut = document.getElementById("filesListOut");
const filesListHint = document.getElementById("filesListHint");

function pretty(x){ return JSON.stringify(x, null, 2); }
function setOut(x){ out.textContent = pretty(x); }
function bytesToGiB(n){
  const giB = n / (1024*1024*1024);
  return (Math.round(giB*100)/100) + " GiB";
}

function summarizeUpdate(data){
  // Если это не объект с полями версии — покажем как есть
  if (!data || typeof data !== "object" || Array.isArray(data)) return data;

  const res = {
    client_version: data.client_version,
    client_url: data.client_url,
    launcher_version: data.launcher_version,
    launcher_url: data.launcher_url,
    files_list: data.files_list,
    api: data.api,
    servers_list: data.servers_list,
    audio_list: data.audio_list,
    radio_list: data.radio_list,
    archives: Array.isArray(data.archives) ? data.archives.map(a => ({
      type: a.type,
      size: (typeof a.size === "number") ? bytesToGiB(a.size) : a.size,
      urls: a.urls
    })) : data.archives
  };

  // чистка undefined
  Object.keys(res).forEach(k => (res[k] === undefined ? delete res[k] : 0));
  return res;
}


function getSessionSnapshot(){
  return {
    accountId: m.accountId,
    sessionHash: m.sessionHash,
    deviceHash: m.deviceHash,
    client: m.client,
    proxyBase: m.proxyBase || null
  };
}

function setSessionOut(x){
  if (!sessionOut) return;
  sessionOut.textContent = pretty(x);
}

function setAdvOut(x){
  if (!advOut) return;
  advOut.textContent = pretty(x);
}

function saveSession(m) {
  const s = { accountId: m.accountId, sessionHash: m.sessionHash, deviceHash: m.deviceHash };
  localStorage.setItem("matreshka_session", JSON.stringify(s));
}
function loadSession(m) {
  try {
    const s = JSON.parse(localStorage.getItem("matreshka_session") || "null");
    if (!s) return;
    m.accountId = s.accountId ?? -1;
    m.sessionHash = (s.sessionHash ?? "");
    m.deviceHash = s.deviceHash || m.deviceHash;
  } catch {}
}

let lastUpdateData = null;

async function loadFilesList(){
  if (!filesListOut) return;
  const url = lastUpdateData?.files_list;
  if (!url) {
    filesListOut.textContent = pretty({ error: "Нет files_list. Сначала нажми 'Обновить' в update.php." });
    return;
  }
  filesListOut.textContent = pretty({loading:true, url});
  try{
    const data = await m.fetchUrl(url);
    window.__filesListRaw = data; // для отладки/сводки
    filesListOut.textContent = pretty(data);
  }catch(e){
    filesListOut.textContent = pretty({error:String(e), url});
  }
}

function summarizeFilesList(data){
  if (!data || typeof data !== "object") return data;

  // Попробуем угадать структуру: либо массив, либо объект с полем files/items
  const arr =
    Array.isArray(data) ? data :
    Array.isArray(data.files) ? data.files :
    Array.isArray(data.items) ? data.items :
    Array.isArray(data.list) ? data.list :
    null;

  if (!arr) {
    // неизвестная структура — покажем ключи верхнего уровня
    return {
      note: "Не удалось распознать массив файлов. Показываю ключи верхнего уровня.",
      keys: Object.keys(data).slice(0, 50)
    };
  }

  // Подсчеты по расширениям и папкам
  const extCount = {};
  const dirCount = {};
  let sample = [];

  for (let i = 0; i < arr.length; i++) {
    const it = arr[i];
    const path = (it?.path || it?.file || it?.name || it?.url || "").toString();
    if (path) {
      const parts = path.split("/");
      const dir = parts.length > 1 ? parts.slice(0, -1).join("/") : "(root)";
      dirCount[dir] = (dirCount[dir] || 0) + 1;

      const m = path.match(/\.([a-z0-9]+)(\?|$)/i);
      const ext = m ? m[1].toLowerCase() : "(none)";
      extCount[ext] = (extCount[ext] || 0) + 1;
    }
    if (sample.length < 20) sample.push(it);
  }

  // Top dirs/exts
  function top(obj, n=15){
    return Object.entries(obj).sort((a,b)=>b[1]-a[1]).slice(0,n).map(([k,v])=>({k,v}));
  }

  return {
    total: arr.length,
    top_extensions: top(extCount, 15),
    top_dirs: top(dirCount, 15),
    sample_first_20: sample
  };
}

async function loadLatestUpdate(){
  if (!latestEl) return;
  latestEl.textContent = pretty({loading:true});
  try{
    const data = await m.getUpdate();
    lastUpdateData = data;
    latestEl.textContent = pretty(summarizeUpdate(data));
    if (filesListHint) filesListHint.textContent = data?.files_list ? (`files_list: ${data.files_list}`) : '';
  }catch(e){
    latestEl.textContent = pretty({error:String(e)});
  }
}

function renderStatus(m) {
  const ok = m.accountId && m.accountId !== -1 && m.sessionHash;
  statusEl.textContent = ok ? `авторизован (accountId=${m.accountId})` : "не авторизован";
  statusEl.className = "pill " + (ok ? "ok" : "");
  devicePill.textContent = `deviceHash=${m.deviceHash}` + (m.proxyBase ? ` | proxy=ON` : ` | proxy=OFF`);
}

const proxyEl = document.getElementById("proxy");
// Вставь сюда URL воркера, например: https://<name>.workers.dev/?url=
const DEFAULT_PROXY_BASE = "";
const m = new Matreshka({
  proxyBase: DEFAULT_PROXY_BASE || null
});
// Подхватить прокси из localStorage (если уже вводил)
try {
  const savedProxy = localStorage.getItem("matreshka_proxyBase");
  if (savedProxy) {
    m.proxyBase = savedProxy;
    proxyEl.value = savedProxy;
  }
} catch {}
// Сохранять прокси при изменении
proxyEl.addEventListener("change", () => {
  const v = proxyEl.value.trim();
  m.proxyBase = v ? v : null;
  try { localStorage.setItem("matreshka_proxyBase", m.proxyBase || ""); } catch {}
});
loadSession(m);
renderStatus(m);

async function run(fn) {
  try {
    setOut({loading:true});
    const res = await fn();
    setOut(res);
    saveSession(m);
    renderStatus(m);
  } catch (e) {
    setOut({ error: String(e), hint: "Если это CORS — смотри README про прокси." });
  }
}

document.getElementById("btnLogin").onclick = () =>
  run(() => m.login(emailEl.value.trim(), passEl.value));

document.getElementById("btnReqCode").onclick = () =>
  run(() => m.requestVerificationCode(emailEl.value.trim(), passEl.value));

document.getElementById("btnRegister").onclick = () =>
  run(() => m.register(emailEl.value.trim(), passEl.value, codeEl.value.trim()));

document.getElementById("btnCall").onclick = () =>
  run(() => m[methodEl.value]());

document.getElementById("btnLogout").onclick = () => {
  localStorage.removeItem("matreshka_session");
  m.accountId = -1;
  m.sessionHash = "";
  m.deviceHash = m.generateDeviceHash();
  renderStatus(m);
  setOut({});
};

document.getElementById("btnCopy").onclick = async () => {
  try {
    await navigator.clipboard.writeText(out.textContent || "");
  } catch (e) {
    alert("Не удалось скопировать: " + e);
  }
};

document.getElementById("btnClear").onclick = () => setOut({});

if (btnShowSession) btnShowSession.addEventListener("click", () => setSessionOut(getSessionSnapshot()));
if (btnClearSession) btnClearSession.addEventListener("click", () => {
  localStorage.removeItem("matreshka_session");
  m.accountId = -1;
  m.sessionHash = "";
  m.deviceHash = m.generateDeviceHash();
  renderStatus(m);
  setSessionOut(getSessionSnapshot());
});
if (btnCopySession) btnCopySession.addEventListener("click", async () => {
  try { await navigator.clipboard.writeText(pretty(getSessionSnapshot())); } catch (e) { alert("Не удалось скопировать: " + e); }
});
if (btnResetDeviceHash) btnResetDeviceHash.addEventListener("click", () => {
  // Внимание: это ломает непройденную регистрацию (код может стать недействительным)
  m.deviceHash = m.generateDeviceHash();
  saveDeviceHash(m.deviceHash);
  renderStatus(m);
  setSessionOut(getSessionSnapshot());
  alert("deviceHash сброшен. Если ты ждешь код регистрации — запроси его заново.");
});

async function runAdv(fn){
  try { setAdvOut({loading:true}); const res = await fn(); setAdvOut(res); saveSession(m); renderStatus(m); }
  catch(e){ setAdvOut({error:String(e)}); }
}

if (btnVerifyAuth) btnVerifyAuth.addEventListener("click", () => runAdv(() => m.verifyAuth()));
if (btnAuthCustom) btnAuthCustom.addEventListener("click", () => {
  const type = (authTypeEl?.value || "").trim() || "email";
  const subtype = (authSubtypeEl?.value || "").trim() || "auth";
  const email = (authEmailEl?.value || "").trim();
  const pass = (authPassEl?.value || "").trim();
  const code = (authCodeEl?.value || "").trim();

  const extra = {};
  // Добавляем параметры только если они не пустые
  if (email) extra.email = email;
  if (pass) {
    extra.pass = pass;
    extra.repeat_pass = pass;
  }
  if (code) extra.code = code;

  return runAdv(async () => {
    const res = await m.authCustom(type, subtype, extra);

    // Попробуем автоматически подхватить сессию из типовых структур ответа
    try {
      const a0 = res?.actions?.[0] || res?.action || null;
      const accountId = a0?.account_id ?? a0?.accountId ?? res?.account_id ?? res?.accountId;
      const sessionHash = a0?.session_hash ?? a0?.sessionHash ?? res?.session_hash ?? res?.sessionHash;
      if (accountId !== undefined && accountId !== null) m.accountId = accountId;
      if (sessionHash !== undefined && sessionHash !== null) m.sessionHash = sessionHash;
    } catch {}

    saveSession(m);
    renderStatus(m);
    setSessionOut(getSessionSnapshot());
    return res;
  });
});
if (btnCharacter) btnCharacter.addEventListener("click", () => runAdv(() => m.character()));
if (btnSelectServer) btnSelectServer.addEventListener("click", () => {
  const ip = (srvIpEl?.value || "").trim();
  const port = (srvPortEl?.value || "").toString().trim();
  // Пытаемся угадать параметры: host/port
  return runAdv(() => m.selectServer({ host: ip || undefined, port: port || undefined }));
});
if (btnPlay) btnPlay.addEventListener("click", () => {
  const ip = (srvIpEl?.value || "").trim();
  const port = (srvPortEl?.value || "").toString().trim();
  return runAdv(() => m.play({ host: ip || undefined, port: port || undefined }));
});
if (btnLogout2) btnLogout2.addEventListener("click", () => runAdv(async () => {
  const res = await m.logout();
  // сброс локальной сессии
  localStorage.removeItem("matreshka_session");
  m.accountId = -1;
  m.sessionHash = "";
  return res;
}));

if (btnLatest) btnLatest.addEventListener("click", () => loadLatestUpdate());
if (btnFilesList) btnFilesList.addEventListener("click", () => loadFilesList());
if (btnFilesListSummary) btnFilesListSummary.addEventListener("click", () => {
  const data = window.__filesListRaw;
  if (!data) {
    if (filesListOut) filesListOut.textContent = pretty({error:"Сначала нажми: Загрузить files_list"});
    return;
  }
  if (filesListOut) filesListOut.textContent = pretty(summarizeFilesList(data));
});
if (autoUpdateEl) {
  try {
    const saved = localStorage.getItem("matreshka_autoUpdate");
    if (saved !== null) autoUpdateEl.checked = (saved === "1");
  } catch {}
  autoUpdateEl.addEventListener("change", () => {
    try { localStorage.setItem("matreshka_autoUpdate", autoUpdateEl.checked ? "1" : "0"); } catch {}
  });
}
// автозагрузка сведений о последней версии
if (autoUpdateEl && autoUpdateEl.checked) { loadLatestUpdate(); }
</script>
</body>
</html>
